ğŸ“Œ REPLIT, preciso que vocÃª faÃ§a a migraÃ§Ã£o completa do meu backend atual (Node.js + Express + better-sqlite3 + uploads locais + Resend + lÃ³gica de eleiÃ§Ãµes) para a arquitetura do Cloudflare Pages. NÃƒO remova recursos nem altere lÃ³gica. Apenas adapte. Siga exatamente as instruÃ§Ãµes abaixo:


---

ğŸŸ¦ 1. Mantenha tudo que jÃ¡ existe

Mesmas rotas

Mesma lÃ³gica de eleiÃ§Ãµes

Mesmo fluxo de membros/candidatos/votos

Mesmo retorno JSON

Mesmas validaÃ§Ãµes

Todo o frontend deve continuar exatamente igual


NÃ£o apague nada do sistema.
Somente converta.


---

ğŸŸ¦ 2. Converter Express â†’ Cloudflare Functions

Cada rota deve virar um arquivo em:

/functions/api/NOME-DA-ROTA.ts

Com formato:

export async function onRequestPost(context) { ... }
export async function onRequestGet(context) { ... }

As rotas DEVE manter os mesmos paths:

/api/login

/api/cadastrar-membro

/api/cadastrar-candidato

/api/listar-membros

/api/listar-eleicoes

/api/votar

/api/enviar-email

etc.



---

ğŸŸ¦ 3. Converter better-sqlite3 â†’ Cloudflare D1

ANTES (Render):

db.prepare("SELECT * FROM membros").all();

DEPOIS (Cloudflare):

await context.env.DB
  .prepare("SELECT * FROM membros")
  .all();

ANTES:

db.prepare("INSERT INTO ...").run();

DEPOIS:

await context.env.DB
  .prepare("INSERT INTO ... VALUES (?, ?, ?)")
  .bind(a, b, c)
  .run();

ğŸ‘‰ Replit, converta TODAS as queries para D1.


---

ğŸŸ¦ 4. Converter uploads locais â†’ Cloudflare R2

ANTES:

fs.writeFileSync("uploads/" + filename, file);

DEPOIS:

await context.env.FOTOS.put(filename, file.stream(), {
  httpMetadata: { contentType: file.type }
});

E gerar URL pÃºblica:

const fotoUrl = `${context.env.R2_PUBLIC_URL}/${filename}`;

Essa URL deve ser salva no banco.


---

ğŸŸ¦ 5. Converter Resend (process.env â†’ context.env)

ANTES:

const resend = new Resend(process.env.RESEND_API_KEY);

DEPOIS:

const resend = new Resend(context.env.RESEND_API_KEY);

E enviar email usando:

await resend.emails.send({
  from: context.env.RESEND_FROM_EMAIL,
  to: destinatario,
  subject,
  html
});


---

ğŸŸ¦ 6. Criar wrangler.toml completamente funcional

Replit, gere o arquivo:

name = "emausvota"
compatibility_date = "2024-01-01"

[[d1_databases]]
binding = "DB"
database_name = "emausvota-db"
database_id = "ID_DO_D1"

[[r2_buckets]]
binding = "FOTOS"
bucket_name = "emausvota-fotos"

[vars]
R2_PUBLIC_URL = "URL_PUBLICA_DO_BUCKET"


---

ğŸŸ¦ 7. Estrutura final de pastas

Replit, reorganize automaticamente para:

/functions
  /api
    login.ts
    cadastrar-membro.ts
    cadastrar-candidato.ts
    listar-membros.ts
    listar-eleicoes.ts
    votar.ts
    enviar-email.ts
/src
  (se houver utilidades)
public/ (frontend original permanece igual)
wrangler.toml
package.json


---

ğŸŸ¦ 8. Manter toda lÃ³gica do sistema

Replit, NÃƒO MUDE:

a lÃ³gica do primeiro/segundo/terceiro escrutÃ­nio

o desempate por idade

o critÃ©rio de presenÃ§a

toda a lÃ³gica de votos

toda a lÃ³gica de cadastro de membros

toda a lÃ³gica de autenticaÃ§Ã£o

todo o controle de cargos

o fluxo de eleiÃ§Ã£o


Apenas adapte para Functions + D1 + R2.


---

ğŸŸ¦ 9. Configurar tudo para deploy no Cloudflare Pages

Backend em /functions/api

Frontend na pasta correta

D1 vinculado via binding "DB"

R2 vinculado via binding "FOTOS"

VariÃ¡veis de ambiente acessÃ­veis via context.env



---

ğŸŸ¦ 10. Gere o cÃ³digo final e faÃ§a todas as substituiÃ§Ãµes necessÃ¡rias automaticamente

Replit, gere:

Todos os novos arquivos .ts

wrangler.toml

Scripts SQL adaptados para D1

CÃ³digo ajustado para R2

CÃ³digo ajustado para Resend

Estrutura final montada


E garanta que:

tudo compile

tudo funcione no Cloudflare

toda lÃ³gica se mantenha intacta



---

ğŸ”¥ FIM DO PROMPT â€“ EXECUTAR COMPLETAMENTE

Replit, faÃ§a TODA a migraÃ§Ã£o automaticamente.