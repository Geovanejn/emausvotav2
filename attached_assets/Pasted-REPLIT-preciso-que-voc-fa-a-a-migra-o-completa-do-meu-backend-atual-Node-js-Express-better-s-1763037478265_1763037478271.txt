REPLIT, preciso que voc√™ fa√ßa a migra√ß√£o completa do meu backend atual (Node.js + Express + better-sqlite3 + uploads locais + Resend + l√≥gica de elei√ß√µes) para a arquitetura do Cloudflare Pages. N√ÉO remova recursos nem altere l√≥gica. Apenas adapte. Siga exatamente as instru√ß√µes abaixo:


---

üü¶ 1. Mantenha tudo que j√° existe

Mesmas rotas

Mesma l√≥gica de elei√ß√µes

Mesmo fluxo de membros/candidatos/votos

Mesmo retorno JSON

Mesmas valida√ß√µes

Todo o frontend deve continuar exatamente igual


N√£o apague nada do sistema.
Somente converta.


---

üü¶ 2. Converter Express ‚Üí Cloudflare Functions

Cada rota deve virar um arquivo em:

/functions/api/NOME-DA-ROTA.ts

Com formato:

export async function onRequestPost(context) { ... }
export async function onRequestGet(context) { ... }

As rotas DEVE manter os mesmos paths:

/api/login

/api/cadastrar-membro

/api/cadastrar-candidato

/api/listar-membros

/api/listar-eleicoes

/api/votar

/api/enviar-email

etc.



---

üü¶ 3. Converter better-sqlite3 ‚Üí Cloudflare D1

ANTES (Render):

db.prepare("SELECT * FROM membros").all();

DEPOIS (Cloudflare):

await context.env.DB
  .prepare("SELECT * FROM membros")
  .all();

ANTES:

db.prepare("INSERT INTO ...").run();

DEPOIS:

await context.env.DB
  .prepare("INSERT INTO ... VALUES (?, ?, ?)")
  .bind(a, b, c)
  .run();

üëâ Replit, converta TODAS as queries para D1.


---

üü¶ 4. Converter uploads locais ‚Üí Cloudflare R2

ANTES:

fs.writeFileSync("uploads/" + filename, file);

DEPOIS:

await context.env.FOTOS.put(filename, file.stream(), {
  httpMetadata: { contentType: file.type }
});

E gerar URL p√∫blica:

const fotoUrl = `${context.env.R2_PUBLIC_URL}/${filename}`;

Essa URL deve ser salva no banco.


---

üü¶ 5. Converter Resend (process.env ‚Üí context.env)

ANTES:

const resend = new Resend(process.env.RESEND_API_KEY);

DEPOIS:

const resend = new Resend(context.env.RESEND_API_KEY);

E enviar email usando:

await resend.emails.send({
  from: context.env.RESEND_FROM_EMAIL,
  to: destinatario,
  subject,
  html
});


---

üü¶ 6. Criar wrangler.toml completamente funcional

Replit, gere o arquivo:

name = "emausvota"
compatibility_date = "2024-01-01"

[[d1_databases]]
binding = "DB"
database_name = "emausvota-db"
database_id = "ID_DO_D1"

[[r2_buckets]]
binding = "FOTOS"
bucket_name = "emausvota-fotos"

[vars]
R2_PUBLIC_URL = "URL_PUBLICA_DO_BUCKET"


---

üü¶ 7. Estrutura final de pastas

Replit, reorganize automaticamente para:

/functions
  /api
    login.ts
    cadastrar-membro.ts
    cadastrar-candidato.ts
    listar-membros.ts
    listar-eleicoes.ts
    votar.ts
    enviar-email.ts
/src
  (se houver utilidades)
public/ (frontend original permanece igual)
wrangler.toml
package.json


---

üü¶ 8. Manter toda l√≥gica do sistema

Replit, N√ÉO MUDE:

a l√≥gica do primeiro/segundo/terceiro escrut√≠nio

o desempate por idade

o crit√©rio de presen√ßa

toda a l√≥gica de votos

toda a l√≥gica de cadastro de membros

toda a l√≥gica de autentica√ß√£o

todo o controle de cargos

o fluxo de elei√ß√£o


Apenas adapte para Functions + D1 + R2.


---

üü¶ 9. Configurar tudo para deploy no Cloudflare Pages

Backend em /functions/api

Frontend na pasta correta

D1 vinculado via binding "DB"

R2 vinculado via binding "FOTOS"

Vari√°veis de ambiente acess√≠veis via context.env



---

üü¶ 10. Gere o c√≥digo final e fa√ßa todas as substitui√ß√µes necess√°rias automaticamente

Replit, gere:

Todos os novos arquivos .ts

wrangler.toml

Scripts SQL adaptados para D1

C√≥digo ajustado para R2

C√≥digo ajustado para Resend

Estrutura final montada


E garanta que:

tudo compile

tudo funcione no Cloudflare

toda l√≥gica se mantenha intacta